---
layout: post
title:  "Linux 虚拟内存学习笔记"
date:   2014-10-06 21:16:28
categories: linux virtualmemory 虚拟内存
---

	
	刚学c语言的时候，老师说malloc，realloc这些函数就是在内存中分配指定大小的存储空间来存放变量，当时认为，就是在物理内存中动态的分配，然后动态的释放。
	
	然而，当时总有一些疑惑，动态分配在内存中的堆中进行，那堆在内存中是如何维护的，大小是如何确定的，多进程的的并行运行，如果共享一个堆，那岂不会乱了
套，如果每个进程都维护各自的堆，那么物理内存够吗。之后的操作系统，也没有给我一个确切的答案，只有进程状态机，进程调度，内存的管理即页，段以及页面调度，
可是这些东西最终在计算机中是如何组织在一块儿，如何协调的工作，操作系统这门课程真的没有提及，仿佛这都是一些独立的知识点，没有联系。后来看了本
《操作系统概念》，初步了解到了虚拟内存这个概念，其他的，就一无所知了。
    初次接触到虚拟内存，或者说是感受到他的存在，是在看《windows via c/c++》这本书，作者Jeffrey Richter编写的随书代码中有个Process information,可以查看进程加载的moudle的，moudle列表的第一条就是此进程的image，然后所有进程的image的baseaddr都是0x00400000，当时不明白为什么都一样，在网上查，说这是windows大多程序默认加载的基地址。可是，所有进程都加载到相同的地址，不会冲突吗？进一步查阅了解，才知道每个进程有自己独立的地址空间，互不冲突，使用的是虚拟内存的技术。进一步的，虚拟内存到物理内存怎么映射，如何管理却没有查到详细的讲解。
直到最近，看了《深入理解计算机系统》这本书，才真正的了解到了虚拟内存这个技术。
说到虚拟内存，首先要说说现在计算机中的存储体系结构，下图为现代计算机的存储体系结构，呈金字塔型，从塔尖到塔底，分别是CPU中的寄存器,即%eax,%ecx,%edx,%ebx,%esi,%edi,%esp等寄存器，L1，L2，L3是cpu芯片中的缓存（SRAM），主存即我们常说的内存（DRAM），然后是硬盘，远程的存储设备
<img src="/images/2014-10-06-linux-virtualmemory/virtualmemory1.jpg" width="800">
存储器的价格与访问速度特性以及程序的局部性决定了这样的存储结构，并且每级存储设备是下级存储设备的缓存。存储设备中的数据按页组织，每当cpu需要读取一定的指令或数据，首先在L1中寻找，如果L1中没有，读取失败，触发页错误异常，触发内核页错误异常处理程序，从L2中读取相应的页进入L1，如果L2中也没有，那就一级一级从下层的存储设备中读取相应的页，直到最终页被存入L1，cpu重新执行读命令，从L1中获取到数据，而这个过程中就用到了我们操作系统中所学到的页面调度（靠近cpu的存储设备采用硬件调度，没有软件算法的参与）。（写入分为直接写入跟写回缓存，写回缓存跟读操作类似，而直接写入是跨过缓存直接写入低层的存储设备）
    那么，虚拟内存是如何与这个存储系统协同工作呢？我们现在的操作系统分为32位和64位，32位的地址空间是 =4GB,64位的地址空间是 =16384PB（1PB=1024TB），这里的地址空间指的就是虚拟地址空间的大小。（注：现在的core i7产品支持的物理地址空间是48bit（256TB）和52bit（4PB）。）而虚拟地址必须转换为物理地址才可以真正访问到物理存储设备。下图是使用虚拟地址的工作方式：
<img src="/images/2014-10-06-linux-virtualmemory/virtualmemory2.jpg" width="800">
当进程运行时，处理器对虚拟地址进行操作，然后CPU将指令操作的虚拟地址传给MMU（存储管理单元），MMU将虚拟地址转换为物理地址（参照页地址转换表page table），然后通过物理地址从计算机的金字塔存储体系中读取或写入数据。当然，这其中有很多的细节，例如，页地址映射表的维护，虚拟地址与物理地址之间的转换，页命中与页错误，页错误异常处理等等。
页地址转换表的维护，首先，虚拟地址对于进程来说是相互独立的，所以，每个进程都维护自己的地址映射表。每个进程可以运行在两种模式下，一种是用户模式，一种是内核模式，进程的虚拟地址空间也分为这两部分，而页地址转换表就维护在内核地址空间中。下图是linux虚拟地址空间：
<img src="/images/2014-10-06-linux-virtualmemory/virtualmemory3.jpg" width="800">
 
不过64位的地址空间稍微有点区别，在用户栈和内核代码和数据之间有一段未定义的区域，从0x00007ffffffff000到0xffff800000000000，用户栈从0x00007ffffffff000向低地址延伸。
以下是我在32位fedora 14中运行brasero，查看/proc/2912/maps所得的结果(brasero进程号是2912)：
<img src="/images/2014-10-06-linux-virtualmemory/virtualmemory4.jpg" width="800">
可以看到，虚拟内存0x08048000-0x080ba000是 /usr/bin/brasero,权限是r-xp即读，执行，私有（copy on write），080ba000-080c6000也是/usr/bin/brasero，权限是rw-p即读，写，私有，紧接着是运行时堆(heap)区域。最后bffdf000-c0000000是用户栈(stack)区域，栈的最高地址是0xc0000000，也是内核虚拟内存的开始地址。不过从0x00110000-0x08048000之间的分配暂时没有查到资料解释。
注：要使栈的开始地址为0xc0000000，必须只需要设置全局变量 randomize_v a_space 值为 0，否则stack每次的开始地址都不一样，有一定的随机偏移，使得使用缓冲区溢出进行攻击更加困难。randomize_v a_space变量的默认值为 1，通过设置 /proc/sys/kernel/randomize_va_space 来停用该特性，也可以用如下命令：sudo sysctl -w kernel.randomize_va_space=0，64位系统同理。
<img src="/images/2014-10-06-linux-virtualmemory/virtualmemory5.jpg" width="800">
 
/usr/bin/rhythmbox开始于0x0000000000400000，栈的最高地址是0x00007ffffffff000，从0x00007ffffffff000到0xffff800000000000之间的地址空间，便于内核虚拟内存不足时的扩展。
 
    回到页地址转换表的话题，页表通常分级存储，存储在内核虚拟空间中，CPU中的CR3寄存器存储着进程页地址转换表的一级页表的物理地址，CR3的值是进程上下文中的一部分，进程上下文切换时会将CR3更新为即将运行进程的一级页表的物理地址。
	
	先写到这里吧
