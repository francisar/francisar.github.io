<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>francisar&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/6a8a4f672a1c31cb6b298ec5f7bf00c0</icon>
  
  <link href="http://tech.mts.cab/atom.xml" rel="self"/>
  
  <link href="http://tech.mts.cab/"/>
  <updated>2022-09-20T10:23:00.860Z</updated>
  <id>http://tech.mts.cab/</id>
  
  <author>
    <name>franciscui</name>
    <email>cpf38267308@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ldap 学习笔记（一）</title>
    <link href="http://tech.mts.cab/2016/07/19/openldap1/"/>
    <id>http://tech.mts.cab/2016/07/19/openldap1/</id>
    <published>2016-07-19T14:47:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ldap-介绍"><a href="#ldap-介绍" class="headerlink" title="ldap 介绍"></a>ldap 介绍</h1><h2 id="目录服务"><a href="#目录服务" class="headerlink" title="目录服务"></a>目录服务</h2><p>目录是一个为查询、浏览和搜索而优化的专业分布式数据库，它呈树状结构组织数据，就好象Linux/Unix系统中的文件目录一样。目录数据库和关系数据库不同，它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。所以目录天生是用来查询的，就好象它的名字一样。</p><p>目录服务是由目录数据库和一套访问协议组成的系统。类似以下的信息适合储存在目录中：</p><p>企业员工信息，如姓名、电话、邮箱等；<br>公用证书和安全密钥；<br>公司的物理设备信息，如服务器，它的IP地址、存放位置、厂商、购买时间等；<br>LDAP是轻量目录访问协议(Lightweight Directory Access Protocol)的缩写，LDAP是从X.500目录访问协议的基础上发展过来的，目前的版本是v3.0。与LDAP一样提供类似的目录服务软件还有ApacheDS、Active Directory、Red Hat Directory Service 。</p><h2 id="ldap特点"><a href="#ldap特点" class="headerlink" title="ldap特点"></a>ldap特点</h2><ul><li>LDAP的结构用树来表示，而不是用表格。正因为这样，就不能用SQL语句了</li><li>LDAP可以很快地得到查询结果，不过在写方面，就慢得多</li><li>LDAP提供了静态数据的快速查询方式</li><li>Client/server模型，Server 用于存储数据，Client提供操作目录信息树的工具</li><li>这些工具可以将数据库的内容以文本格式（LDAP 数据交换格式，LDIF）呈现在您的面前</li><li>LDAP是一种开放Internet标准，LDAP协议是跨平台的Interent协议</li></ul><h1 id="LDAP组织数据的方式"><a href="#LDAP组织数据的方式" class="headerlink" title="LDAP组织数据的方式"></a>LDAP组织数据的方式</h1><script>var graph = new Q.Graph(canvas);graph.zoomToOverview();var basedn = createStep("dc=franciscui,dc=cn", 220, 100, "base dn");var people = createSmallStep("ou=People", 280, 200,  basedn);var root = createSmallStep("uid=root", 230, 300,  people);var www = createSmallStep("uid=www", 330, 300,  people);var admin = createSmallStep("ou=Admin", 180, 200,  basedn);var group = createSmallStep("ou=Group", 380, 200,  basedn);var www_group = createSmallStep("cn=www", 430, 300,  group);createEdge(basedn, people, 1);createEdge(basedn, admin, 1);createEdge(basedn, group, 1);createEdge(group, www_group, 1);createEdge(people, root, 1);createEdge(people, www, 1);</script><h2 id="1-Entry"><a href="#1-Entry" class="headerlink" title="1 Entry"></a>1 Entry</h2><p>条目，也叫记录项，是LDAP中最基本的颗粒，就像字典中的词条，或者是数据库中的记录。通常对LDAP的添加、删除、更改、检索都是以条目为基本对象的。</p><p>dn：每一个条目都有一个唯一的标识名（distinguished Name ，DN），如上图中一个 dn：”cn=baby,ou=marketing,ou=people,dc=mydomain,dc=org” 。通过DN的层次型语法结构，可以方便地表示出条目在LDAP树中的位置，通常用于检索。</p><p>rdn：一般指dn逗号最左边的部分，如cn=baby。它与RootDN不同，RootDN通常与RootPW同时出现，特指管理LDAP中信息的最高权限用户。</p><p>Base DN：LDAP目录树的最顶部就是根，也就是所谓的“Base DN”，如”dc=mydomain,dc=org”。</p><h2 id="2-Attribute"><a href="#2-Attribute" class="headerlink" title="2 Attribute"></a>2 Attribute</h2><p>每个条目都可以有很多属性（Attribute），比如常见的人都有姓名、地址、电话等属性。每个属性都有名称及对应的值，属性值可以有单个、多个，比如你有多个邮箱。</p><p>属性不是随便定义的，需要符合一定的规则，而这个规则可以通过schema制定。比如，如果一个entry没有包含在 inetorgperson 这个 schema 中的objectClass: inetOrgPerson，那么就不能为它指定employeeNumber属性，因为employeeNumber是在inetOrgPerson中定义的。</p><p>LDAP为人员组织机构中常见的对象都设计了属性(比如commonName，surname)。下面有一些常用的别名：</p><h2 id="3-ObjectClass"><a href="#3-ObjectClass" class="headerlink" title="3 ObjectClass"></a>3 ObjectClass</h2><p>对象类是属性的集合，LDAP预想了很多人员组织机构中常见的对象，并将其封装成对象类。比如人员（person）含有姓（sn）、名（cn）、电话(telephoneNumber)、密码(userPassword)等属性，单位职工(organizationalPerson)是人员(person)的继承类，除了上述属性之外还含有职务（title）、邮政编码（postalCode）、通信地址(postalAddress)等属性。</p><p>通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。如果2个对象类中有相同的属性，则条目继承后只会保留1个属性。对象类同时也规定了哪些属性是基本信息，必须含有(Must 活Required，必要属性)：哪些属性是扩展信息，可以含有（May或Optional，可选属性）。</p><p>对象类有三种类型：结构类型（Structural）、抽象类型(Abstract)和辅助类型（Auxiliary）。结构类型是最基本的类型，它规定了对象实体的基本属性，每个条目属于且仅属于一个结构型对象类。抽象类型可以是结构类型或其他抽象类型父类，它将对象属性中共性的部分组织在一起，称为其他类的模板，条目不能直接集成抽象型对象类。辅助类型规定了对象实体的扩展属性。每个条目至少有一个结构性对象类。</p><p>对象类本身是可以相互继承的，所以对象类的根类是top抽象型对象类。以常用的人员类型为例，他们的继承关系：</p><div style="height: 500px;" id="canvas1"/><br><script><br>var graph = new Q.Graph(canvas1);<br>graph.zoomToOverview();<br><br><br><br><br>function createEdge(from, to, lineWidth, dash){<br>        var edge = graph.createEdge(from, to);<br>        edge.setStyle(Q.Styles.EDGE_WIDTH, lineWidth || 3);<br>        edge.setStyle(Q.Styles.EDGE_COLOR, “#1D4876”);<br>    if(dash){<br>                edge.setStyle(Q.Styles.EDGE_LINE_DASH, [10, 10]);<br><br>    }<br>        return edge;<br><br>}<br>function createAssistNode(label, x, y, parent){<br>        var node = graph.createText(label, x, y);<br>        node.setStyle(Q.Styles.LABEL_BORDER, 1);<br>        node.setStyle(Q.Styles.LABEL_BORDER_STYLE, “#A020F0”);<br>        node.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>        node.setStyle(Q.Styles.LABEL_PADDING, 5);<br>        node.setStyle(Q.Styles.LABEL_SIZE, new Q.Size(70, 35));<br>        node.setStyle(Q.Styles.LABEL_BACKGROUND_COLOR, “#FFF”);<br>        node.anchorPosition = Q.Position.LEFT_TOP;<br>    if(parent){<br>                node.parent = parent;<br>                node.host = parent;<br><br>    }<br>        return node;<br><br>}<br>function createStructNode(label, x, y, parent){<br>        var node = graph.createText(label, x, y);<br>        node.setStyle(Q.Styles.LABEL_BORDER, 1);<br>        node.setStyle(Q.Styles.LABEL_BORDER_STYLE, “#ED9121”);<br>        node.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>        node.setStyle(Q.Styles.LABEL_PADDING, 5);<br>        node.setStyle(Q.Styles.LABEL_SIZE, new Q.Size(70, 35));<br>        node.setStyle(Q.Styles.LABEL_BACKGROUND_COLOR, “#FFF”);<br>        node.anchorPosition = Q.Position.LEFT_TOP;<br>    if(parent){<br>                node.parent = parent;<br>                node.host = parent;<br><br>    }<br>        return node;<br><br>}<br>function createAbstractNode(label, x, y, parent){<br>        var node = graph.createText(label, x, y);<br>        node.setStyle(Q.Styles.LABEL_BORDER, 1);<br>        node.setStyle(Q.Styles.LABEL_BORDER_STYLE, “#1D4876”);<br>        node.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>        node.setStyle(Q.Styles.LABEL_PADDING, 5);<br>        node.setStyle(Q.Styles.LABEL_SIZE, new Q.Size(70, 35));<br>        node.setStyle(Q.Styles.LABEL_BACKGROUND_COLOR, “#FFF”);<br>        node.anchorPosition = Q.Position.LEFT_TOP;<br>    if(parent){<br>                node.parent = parent;<br>                node.host = parent;<br><br>    }<br>        return node;<br><br>}<br>var AbstractNode = createAbstractNode(“抽象类型”, 400, 50);<br>var StructNode = createStructNode(“结构类型”, 400, 100);<br>var AssistNode = createAssistNode(“辅助类型”, 400, 150);<br>var atop = createAbstractNode(“top”, 220, 100);<br>var person = createStructNode(“person”, 220, 170);<br>var organizationalPerson = createStructNode(“organizationalPerson”, 20,240,person);<br>var residentialPerson = createStructNode(“residentialPerson”, 200, 240,  person);<br>var ePerson = createAssistNode(“ePerson”, 380, 240,  person);<br>var inetOrgPerson = createStructNode(“inetOrgPerson”, 20, 310,  organizationalPerson);<br>createEdge(person, atop, 1);<br>createEdge(organizationalPerson, person, 1);<br>createEdge(residentialPerson, person, 1);<br>createEdge(ePerson, person, 1);<br>createEdge(inetOrgPerson, organizationalPerson, 1);<br></script><br></div><p>下面是inetOrgPerson对象类的在schema中的定义，可以清楚的看到它的父类SUB和可选属性MAY、必要属性MUST(继承自organizationalPerson)，关于各属性的语法则在schema中的attributetype定义。</p><!--lang:c--><pre><code># inetOrgPerson# The inetOrgPerson represents people who are associated with an# organization in some way.  It is a structural class and is derived# from the organizationalPerson which is defined in X.521 [X521].objectclass     ( 2.16.840.1.113730.3.2.2    NAME &apos;inetOrgPerson&apos;        DESC &apos;RFC2798: Internet Organizational Person&apos;    SUP organizationalPerson    STRUCTURAL        MAY (            audio $ businessCategory $ carLicense $ departmentNumber $            displayName $ employeeNumber $ employeeType $ givenName $            homePhone $ homePostalAddress $ initials $ jpegPhoto $            labeledURI $ mail $ manager $ mobile $ o $ pager $            photo $ roomNumber $ secretary $ uid $ userCertificate $            x500uniqueIdentifier $ preferredLanguage $            userSMIMECertificate $ userPKCS12 )        )</code></pre><h2 id="4-Schema"><a href="#4-Schema" class="headerlink" title="4 Schema"></a>4 Schema</h2><p>对象类（ObjectClass）、属性类型（AttributeType）、语法（Syntax）分别约定了条目、属性、值，他们之间的关系如下图所示。所以这些构成了模式(Schema)——对象类的集合。条目数据在导入时通常需要接受模式检查，它确保了目录中所有的条目数据结构都是一致的。</p><div style="height: 500px;" id="canvas2"/><br><script><br>var graph = new Q.Graph(canvas2);<br>//graph.moveToCenter(0);<br>graph.zoomOut(0,0);<br>graph.zoomOut(0,0);<br>tiaomu = createTextwithBox(“条目”,100,100)<br>tiaomu.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>tiaomu.setStyle(Q.Styles.LABEL_FONT_SIZE, 20);<br>tiaomu.setStyle(Q.Styles.LABEL_SIZE, {width: 340, height: 350});<br>must = createTextwithBox(“must”,20,120,tiaomu)<br>must.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>must.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>must.setStyle(Q.Styles.LABEL_SIZE, {width: 120, height: 280});<br>may = createTextwithBox(“may”,180,120,tiaomu)<br>may.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>may.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>may.setStyle(Q.Styles.LABEL_SIZE, {width: 120, height: 280});<br><br>object1box = createTextwithBox(“   “,100,80,must)<br>object1box.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>object1box.setStyle(Q.Styles.ALPHA, 0.5);<br>object1box.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>object1box.setStyle(Q.Styles.LABEL_SIZE, {width: 250, height: 100});<br><br>object2box = createTextwithBox(“   “,100,200,must)<br>object2box.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>object2box.setStyle(Q.Styles.ALPHA, 0.5);<br>object2box.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>object2box.setStyle(Q.Styles.LABEL_SIZE, {width: 250, height: 60});<br><br>Object1 = createTextwithBox(“对象类1”,-200,100,null,”#000”,14,”#5E2612”)<br>Object2 = createTextwithBox(“对象类2”,-200,200,null,”#000”,14,”#5E2612”)<br><br><br>attr1 = createTextwithBox(“属性1”,20,50,must,”#000”,14,”#5E2612”)<br>attr2 = createTextwithBox(“属性2”,20,100,must,”#000”,14,”#5E2612”)<br>attr3 = createTextwithBox(“属性3”,20,200,must,”#000”,14,”#5E2612”)<br>attr4 = createTextwithBox(“属性4”,180,100,may,”#000”,14,”#5E2612”)<br>attr5 = createTextwithBox(“属性5”,180,200,may,”#000”,14,”#5E2612”)<br><br><br><br>attr = createTextwithBox(“属性类型”,400,180)<br>attr.setStyle(Q.Styles.LABEL_ALIGN_POSITION, Q.Position.CENTER_TOP);<br>attr.setStyle(Q.Styles.LABEL_FONT_SIZE, 16);<br>attr.setStyle(Q.Styles.LABEL_SIZE, {width: 120, height: 200});<br><br><br>value1 = createTextwithBox(“值1”,400,140,attr,”#000”,14,”#5E2612”)<br>value2 = createTextwithBox(“值2”,400,200,attr,”#000”,14,”#5E2612”)<br>attr_type = createTextwithBox(“值2”,400,200,attr,”#000”,14,”#5E2612”)<br>createEdge_arrow(attr5,attr,1)<br>createEdge_arrow(Object1,object1box,1)<br>createEdge_arrow(Object2,object2box,1)<br><br></script><br></div><p>schema（一般在/etc/ldap/schema/目录）在导入时要注意前后顺序。</p><h2 id="5-backend-amp-database"><a href="#5-backend-amp-database" class="headerlink" title="5 backend &amp; database"></a>5 backend &amp; database</h2><p>ldap的后台进程slapd接收、响应请求，但实际存储数据、获取数据的操作是由Backends做的，而数据是存放在database中，所以你可以看到往往你可以看到backend和database指令是一样的值如 bdb 。一个 backend 可以有多个 database instance，但每个 database 的 suffix 和 rootdn 不一样。openldap 2.4版本的模块是动态加载的，所以在使用backend时需要moduleload back_bdb指令。</p><p>bdb是一个高性能的支持事务和故障恢复的数据库后端，可以满足绝大部分需求。许多旧文档里（包括官方）说建议将bdb作为首选后端服务（primary backend），但2.4版文档明确说hdb才是被首先推荐使用的，这从 2.4.40 版默认安装后的配置文件里也可以看出。hdb是基于bdb的，但是它通过扩展的索引和缓存技术可以加快数据访问，修改entries会更有效率，有兴趣可以访问上的链接或slapd.backends。</p><p>另外config是特殊的backend，用来在运行时管理slapd的配置，它只能有一个实例，甚至无需显式在slapd.conf中配置。</p><h2 id="6-LDIF"><a href="#6-LDIF" class="headerlink" title="6 LDIF"></a>6 LDIF</h2><p>LDIF（LDAP Data Interchange Format，数据交换格式）是LDAP数据库信息的一种文本格式，用于数据的导入导出，每行都是“属性: 值”对</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ldap-介绍&quot;&gt;&lt;a href=&quot;#ldap-介绍&quot; class=&quot;headerlink&quot; title=&quot;ldap 介绍&quot;&gt;&lt;/a&gt;ldap 介绍&lt;/h1&gt;&lt;h2 id=&quot;目录服务&quot;&gt;&lt;a href=&quot;#目录服务&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="ldap" scheme="http://tech.mts.cab/categories/ldap/"/>
    
    
    <category term="openldap" scheme="http://tech.mts.cab/tags/openldap/"/>
    
  </entry>
  
  <entry>
    <title>svn 编译支持http协议问题</title>
    <link href="http://tech.mts.cab/2016/07/18/svn_compile/"/>
    <id>http://tech.mts.cab/2016/07/18/svn_compile/</id>
    <published>2016-07-18T14:27:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<p>svn 版本1.9.4<br>系统centos6.2<br>编译安装的svn是成功了，在linux上执行 svn checkout http://…. 命令时候报错<br>svn: E170000: Unrecognized URL scheme for<br>执行svn –version</p><!--language:c--><pre><code>svn, version 1.9.4 (r1740329)compiled Jul 18 2016, 14:01:25 on x86_64-unknown-linux-gnuCopyright (C) 2016 The Apache Software Foundation.This software consists of contributions made by many people;see the NOTICE file for more information.Subversion is open source software, see http://subversion.apache.org/The following repository access (RA) modules are available:   * ra_svn : Module for accessing a repository using the svn network protocol.     - with Cyrus SASL authentication     - handles &apos;svn&apos; scheme   * ra_local : Module for accessing a repository on local disk.     - handles &apos;file&apos; scheme</code></pre><p>没有’http’ scheme。</p><p>原来，svn1.8版本以后，需要serf软件包支持访问 http 协议的版本库，不然就会报错.serf需要用scons来编译安装，所以先安装下scons</p><!--language:c--><pre><code>pip install scons</code></pre><p>注：如果是自己编译的python版本，scons安装成功后，再python的bin路径下编辑下scons文件，将首行#! /usr/bin/env python 修改为自己编译的python执行路径</p><p>svn 1.9.4版本需要serf1.3.4以上版本，我下载的是1.3.8</p><!--language:c--><pre><code>wget https://archive.apache.org/dist/serf/serf-1.3.8.tar.bz2tar -xvf serf-1.3.8.tar.bz2cd serf-1.3.8scons PREFIX=/usr/local/serf APR=/apps/apr/bin/apr-1-config APU=/apps/apr-util/bin/apu-1-configscons installscons -c</code></pre><p>重新编译svn 加上 –with-serf=/usr/local/serf</p><!--language:c--><pre><code>./configure  --with-serf=/usr/local/serf</code></pre><p>然后将serf的lib路径添加到系统搜索路径</p><!--language:c--><pre><code>vim /etc/ld.so.conf.d/serf.conf加入内容：/usr/local/serf/libldconfig</code></pre><p>否则会报错<br>svn: error while loading shared libraries: libserf-1.so.1: cannot open shared object file: No such file or directory</p><p>svn –version 看下信息</p><!--language:c--><pre><code>svn, version 1.9.4 (r1740329)compiled Jul 18 2016, 14:01:25 on x86_64-unknown-linux-gnuCopyright (C) 2016 The Apache Software Foundation.This software consists of contributions made by many people;see the NOTICE file for more information.Subversion is open source software, see http://subversion.apache.org/The following repository access (RA) modules are available:* ra_svn : Module for accessing a repository using the svn network protocol.    - with Cyrus SASL authentication    - handles &apos;svn&apos; scheme* ra_local : Module for accessing a repository on local disk.    - handles &apos;file&apos; scheme* ra_serf : Module for accessing a repository via WebDAV protocol using serf.    - using serf 1.3.8 (compiled with 1.3.8)    - handles &apos;http&apos; scheme    - handles &apos;https&apos; scheme</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;svn 版本1.9.4&lt;br&gt;系统centos6.2&lt;br&gt;编译安装的svn是成功了，在linux上执行 svn checkout http://…. 命令时候报错&lt;br&gt;svn: E170000: Unrecognized URL scheme for&lt;br&gt;执行svn </summary>
      
    
    
    
    <category term="subversion" scheme="http://tech.mts.cab/categories/subversion/"/>
    
    
    <category term="svn http" scheme="http://tech.mts.cab/tags/svn-http/"/>
    
  </entry>
  
  <entry>
    <title>hadoop snappy压缩</title>
    <link href="http://tech.mts.cab/2016/04/09/hadoop_learn1/"/>
    <id>http://tech.mts.cab/2016/04/09/hadoop_learn1/</id>
    <published>2016-04-09T04:49:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<p>hdfs dfs -du -s -h /lagou/logs/lg-main-nginx/20160401<br>28.2 G  56.6 G  /lagou/logs/lg-main-nginx/20160401<br>hdfs dfs -ls -h /lagou/logs/backup/lg-main-nginx/201604<br>-rw-r–r–   2 root supergroup       9.7 G 2016-04-09 12:40 /lagou/logs/backup/lg-main-nginx/201604/access.20160401.snappy<br>real    7m28.633s<br>user    2m7.403s<br>sys     1m7.918s</p><p>64Mb/s</p><p>real    10m47.011s<br>user    1m42.091s<br>sys     0m49.264s</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hdfs dfs -du -s -h /lagou/logs/lg-main-nginx/20160401&lt;br&gt;28.2 G  56.6 G  /lagou/logs/lg-main-nginx/20160401&lt;br&gt;hdfs dfs -ls -h /lagou/log</summary>
      
    
    
    
    <category term="hadoop" scheme="http://tech.mts.cab/categories/hadoop/"/>
    
    
    <category term="hadoop hdfs snappy java" scheme="http://tech.mts.cab/tags/hadoop-hdfs-snappy-java/"/>
    
  </entry>
  
  <entry>
    <title>python shell交互与历史命令</title>
    <link href="http://tech.mts.cab/2016/04/05/python_learn2/"/>
    <id>http://tech.mts.cab/2016/04/05/python_learn2/</id>
    <published>2016-04-05T05:20:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<p>python的开发过程中，我们总会打开python的交互式终端，来进行一些代码测试，自己编译的python版本，在使用过程中发现无法使用上下左右键，导致使用起来非常不便。Linux中自带的python版本，都可以像GNU bash shell一样，可以左右编辑当前input，上下选择历史input。</p><p>python的交互式终端，input编辑以及历史命令的选择，依赖于GNU readline library,因此在编译python前，需要先安装readline-devel。<br>已经编译完成的，安装readline-devel后，可以通过easy_install readline的方式来添加此功能（未测试）。</p><h2 id="Key-Bindings"><a href="#Key-Bindings" class="headerlink" title="Key Bindings"></a>Key Bindings</h2><p>在python的终端中，可以进行一些自定义的设置，具体设置内容存放在~/.inputrc。<br>按键的自定义设置：<br>key-name: function-name<br>例如讲tab键设置自动补全<br>Tab: complete<br>（不过设置完以后发现无法根据python语法进行自动补全）</p><p>也可以进行其他的一些选项设置<br>例如：<br>set horizontal-scroll-mode On  #如果输入超过了screen宽度，仍然单行显示</p><p>选项以及按键自定义设置具体可以参考<a href="http://web.mit.edu/gnu/doc/html/rlman_1.html">这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;python的开发过程中，我们总会打开python的交互式终端，来进行一些代码测试，自己编译的python版本，在使用过程中发现无法使用上下左右键，导致使用起来非常不便。Linux中自带的python版本，都可以像GNU bash shell一样，可以左右编辑当前input</summary>
      
    
    
    
    <category term="python" scheme="http://tech.mts.cab/categories/python/"/>
    
    
    <category term="python python交互shell" scheme="http://tech.mts.cab/tags/python-python%E4%BA%A4%E4%BA%92shell/"/>
    
  </entry>
  
  <entry>
    <title>python eval踩坑后</title>
    <link href="http://tech.mts.cab/2016/03/31/python_learn1/"/>
    <id>http://tech.mts.cab/2016/03/31/python_learn1/</id>
    <published>2016-03-31T05:14:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>最近在做一个数据采集的功能，每5分钟采集一次数据，由于数据是从日志中采集分析，通过crontab给spark提交任务去计算的，spark任务无法保证是在整5分钟间隔的时候执行（比如：00分，5分，10分），所以需要对当前时间做下处理，将非整5分钟的时间修改为整5分钟，然后做日志筛选<br>时间处理的具体代码如下:<br><!--lang:python--></p><pre><code>now = time.time() - 300                                   #当前时间延后5分钟 daypath = time.strftime(&quot;%Y%m%d&quot;,time.localtime(now))     #取当天的日志路径hour = time.strftime(&quot;%H%M&quot;,time.localtime(now))          #取小时分钟minute = eval(hour)                                       #讲小时分钟转换为数字 minute = minute - (minute % 5)                            #将分钟对5取模，减去余数rowkey = &quot;%s%04d&quot; % (daypath,minute)                      #生成hbase rowkey(201603301320)end = time.mktime(time.strptime(rowkey,&apos;%Y%m%d%H%M&apos;))     #将rowkey换算为时间戳 begin = end - 300                                         #取begin到end之间的日志</code></pre><p>以上代码在白天运行时毫无问题，但是到凌晨一点开始，没有计算没有数据了<br>经过分析发现，minute = eval(hour) 在晚上1点开始的时候，假设hour是0115，eval转换时会将hour视为八进制的数字，所以转换以后是163<br>minute = minute - (minute % 5)后，minute变为160，rowkey = “%s%04d” % (daypath,minute） 执行后，rowkey为201603300160，时间完全错<br>了，自然筛选不到日志</p><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><!--lang:python--><pre><code>eval(expression[, globals[, locals]])</code></pre><p>The expression argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the globals and locals dictionaries as global and local namespace. If the globals dictionary is present and lacks ‘<strong>builtins</strong>’, the current globals are copied into globals before expression is parsed. This means that expression normally has full access to the standard <strong>builtin</strong> module and restricted environments are propagated. If the locals dictionary is omitted it defaults to the globals dictionary. If both dictionaries are omitted, the expression is executed in the environment where eval() is called. The return value is the result of the evaluated expression.</p><p>expression参数会被解析为python表达式来执行，eval有三个参数，expression，globals，locals，globals和locals可选，传入字典，分别对应expression全局命名空间和局部命名空间，globals传入的字典中如果没有<strong>builtins</strong>，当前全局<strong>builtins</strong>将会在expression执行前传入globals</p><h2 id="python变量解析原则"><a href="#python变量解析原则" class="headerlink" title="python变量解析原则"></a>python变量解析原则</h2><p>我们都知道python变量名解析遵循LEGB原则，即首先是本地,之后是函数内，之后是全局，最后是内置。<br>在默认的情况下，变量名赋值会创建或者改变本地变量当函数中使用未认证的变量名时，Python就会搜索4个作用域（本地作用域，之后是上一层结构中def或lambda的本地作用域，之后是全局作用域，最后是内置作用域。<br>以下面代码为例:<br><!--lang:python--></p><pre><code>g = &apos;I am global&apos;def local():    e = &apos;I am function&apos;    if g is not None:        l = &apos;I am local&apos;        print g,e,l,len(g)</code></pre><p>代码1-1</p><p>从如上代码看：<br>在print g,e,l执行时，l来自本地变量，e来自函数内变量，g为全局变量,那么什么是内置变量呢，内置变量就是上面所说的<strong>builtins</strong>相关，而len(g)中的len来自内置变量</p><h2 id="python内置变量"><a href="#python内置变量" class="headerlink" title="python内置变量"></a>python内置变量</h2><p>在Python中，有一个内建模块，该模块中有一些常用函数;而该模块在Python启动后、且没有执行程序员所写的任何代码前，Python会首先加载该内建函数到内存。另外，该内建模块中的功能可以直接使用，不用在其前添加内建模块前缀。比如：内建模块中有一个len()函数，计算一个对象的长度，如len(‘aaa’)将返回3。</p><p>在Python2.X版本中，内建模块被命名为<strong>builtin</strong>，而到了Python3.X版本中，却更名为builtins</p><p>当使用内建模块中函数或其它功能时，可以直接使用，不用添加内建模块的名字;但是，如果想要向内建模块中添加一些功能，以便在任何函数中都能直接使用而不用再进行import，这时，就要导入内建模块，在内建模块的命名空间(即<strong>dict</strong>字典属性)中添加该功能。在导入时，如果是Python2.X版本，就要导入<strong>builtin</strong>模块;如果是Python3.X版本，就要导入builtins模块。</p><p>例如实现一个加法函数并导入内建变量</p><p>python2:<br><!--lang:python--></p><pre><code>import __builtin__def add(x,y):    return x+y__builtin__.__dict__[&apos;add&apos;] = add</code></pre><p>代码2-1</p><p>python3:<br><!--lang:python--></p><pre><code>import builtinsdef add(x,y):    return x+ybuiltins.__dict__[&apos;add&apos;] = add</code></pre><p>代码2-2</p><p>那<strong>builtins</strong>是什么呢</p><p><strong>builtins</strong>即是引用，那么它内建模块有一个相同点：Python程序一旦启动，它们二者就会在程序员所写的代码没有运行之前就已经被加载到内存中了</p><ol><li>在主模块<strong>main</strong>中：<br><strong>builtins</strong>是对内建模块<strong>builtin</strong>本身的引用，即<strong>builtins</strong>完全等价于<strong>builtin</strong>，二者完全是一个东西，不分彼此。它在任何地方都可见，即在任何地方都可使用它。此时，<strong>builtins</strong>的类型是模块类型。<br><strong>builtin</strong>仅仅在导入它时才可见。哪个作用域中使用<strong>builtin</strong>，哪个作用域就要导入它(导入仅仅是让<strong>builitin</strong>标识符在该作用域内可见)。一般都是在模块的顶层(即模块的全局作用域)导入<strong>builtin</strong>，这样，其后的任何作用域可通过标识符向上查找来引用<strong>builtin</strong>。</li><li>在非<strong>main</strong>模块中：<br><strong>builtins</strong>仅是对<strong>builtin</strong>.<strong>dict</strong>的引用，而非<strong>builtin</strong>本身。它在任何地方都可见。此时<strong>builtins</strong>的类型是字典。</li></ol><h2 id="再看eval"><a href="#再看eval" class="headerlink" title="再看eval"></a>再看eval</h2><p>eval(expression[, globals[, locals]])</p><p>当globals和locals为空时，expression运行在当前eval运行的全局名称空间和本地名称空间<br>当globals为空，locals不为空时，全局名称空间为当前eval运行的全局命名空间，本地名称空间为locals的传值<br>当globals不为空，expression的全局名称空间为globals（包括内置名称空间），如果locals为空，本地名称空间继承globals，如果locals不为空，expression的本地名称空间为locals<br><!--lang:python--></p><pre><code>g = &apos;I am global&apos;def local():    e = &apos;I am function&apos;    if g is not None:        l = &apos;I am local&apos;        eval(&quot;e&quot;,None,&#123;&apos;m&apos;:123&#125;)  #NameError        eval(&quot;l&quot;,None,&#123;&apos;m&apos;:123&#125;)  #NameError        eval(&quot;g&quot;,None,&#123;&apos;m&apos;:123&#125;)  #&apos;I am global&apos;        eval(&quot;g&quot;,&#123;&#125;,&#123;&apos;m&apos;:123&#125;)    #NameError</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;踩坑&quot;&gt;&lt;a href=&quot;#踩坑&quot; class=&quot;headerlink&quot; title=&quot;踩坑&quot;&gt;&lt;/a&gt;踩坑&lt;/h2&gt;&lt;p&gt;最近在做一个数据采集的功能，每5分钟采集一次数据，由于数据是从日志中采集分析，通过crontab给spark提交任务去计算的，spark任务</summary>
      
    
    
    
    <category term="python" scheme="http://tech.mts.cab/categories/python/"/>
    
    
    <category term="python LEGB eval" scheme="http://tech.mts.cab/tags/python-LEGB-eval/"/>
    
  </entry>
  
  <entry>
    <title>基于公有云建设私有网络（三）</title>
    <link href="http://tech.mts.cab/2015/12/13/CentOS_openvpn/"/>
    <id>http://tech.mts.cab/2015/12/13/CentOS_openvpn/</id>
    <published>2015-12-13T06:41:00.000Z</published>
    <updated>2022-09-20T10:23:00.859Z</updated>
    
    <content type="html"><![CDATA[<p>接下来是openvpn的配置</p><h2 id="openvpn介绍"><a href="#openvpn介绍" class="headerlink" title="openvpn介绍"></a>openvpn介绍</h2><p>OpenVpn的技术核心是虚拟网卡，其次是SSL协议实现，由于SSL协议在其它的词条中介绍的比较清楚了，这里重点对虚拟网卡及其在OpenVpn的中的工作机理进行介绍：虚拟网卡是使用网络底层编程技术实现的一个驱动软件，安装后在主机上多出现一个网卡，可以像其它网卡一样进行配置。服务程序可以在应用层打开虚拟网卡，如果应用软件（如IE）向虚拟网卡发送数据，则服务程序可以读取到该数据，如果服务程序写合适的数据到虚拟网卡，应用软件也可以接收得到。虚拟网卡在很多的操作系统下都有相应的实现，这也是OpenVpn能够跨平台一个很重要的理由。</p><h2 id="openvpn服务端配置"><a href="#openvpn服务端配置" class="headerlink" title="openvpn服务端配置"></a>openvpn服务端配置</h2><p>安装不做赘述，主要是配置文件<br><!--lang:bash--></p><pre><code>local       100.1.100.3                                 ;服务器监听的IP地址port        1194                                        ;端口proto       udp                                         ;协议使用udpdev         tun                                         ;使用tun模式（还有一种模式是tap）ca          /etc/openvpn/easy-rsa/2.0/keys/ca.crt       ;ca证书cert        /etc/openvpn/easy-rsa/2.0/keys/server.crt   ;服务器证书key         /etc/openvpn/easy-rsa/2.0/keys/server.key   ;服务器密钥dh          /etc/openvpn/easy-rsa/2.0/keys/dh2048.pem   server      172.16.1.0 255.255.255.0                    ;给客户端分配的IP地址段push        &quot;route 192.168.2.0 255.255.255.0&quot;           ;推送给客户端的路由，使远程接入的员工可以访问北京办公网push        &quot;route 172.16.2.0 255.255.255.0&quot;            ;使远程办公员工可以访问公有云虚拟出来的网段push        &quot;route 192.168.3.0 255.255.255.0&quot;           ;使远程接入的员工可以访问天津办公网push        &quot;dhcp-option DNS 192.168.2.200&quot;             ;推送内部dns服务器地址为客户端dnslog         /data/log/openvpn.logkeepalive   10 120verb        3client-to-clientcomp-lzopersist-keypersist-tun</code></pre><h2 id="openvpn客户端"><a href="#openvpn客户端" class="headerlink" title="openvpn客户端"></a>openvpn客户端</h2><p>客户端配置文件如下<br><!--lang:bash--></p><pre><code>clientproto udpdev tunremote 100.1.100.3  1194  ca ca.crtcert client.crtkey client.key  dh dh2048.pemkeepalive 10 120comp-lzocomp-noadaptuser daemongroup daemonpersist-keypersist-tunstatus openvpn-status.logverb 3</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><pre><code>至此，一个简单的多地域办公+远程办公的网络环境建立完成</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接下来是openvpn的配置&lt;/p&gt;
&lt;h2 id=&quot;openvpn介绍&quot;&gt;&lt;a href=&quot;#openvpn介绍&quot; class=&quot;headerlink&quot; title=&quot;openvpn介绍&quot;&gt;&lt;/a&gt;openvpn介绍&lt;/h2&gt;&lt;p&gt;OpenVpn的技术核心是虚拟网卡，其次</summary>
      
    
    
    
    <category term="网络技术" scheme="http://tech.mts.cab/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VPN openvpn 网络" scheme="http://tech.mts.cab/tags/VPN-openvpn-%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>metric server部署问题排查</title>
    <link href="http://tech.mts.cab/2015/12/13/calico_throubleshooting/"/>
    <id>http://tech.mts.cab/2015/12/13/calico_throubleshooting/</id>
    <published>2015-12-13T06:41:00.000Z</published>
    <updated>2022-09-21T04:20:33.296Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><p>查看calico node日志<br><!--lang:bash--><br>    crictl ps</p><pre><code>CONTAINER           IMAGE               CREATED             STATE               NAME                ATTEMPT             POD ID              POD63acc9016d719       5f5175f39b19e       34 hours ago        Running             calico-node         0                   da931628d63e7       calico-node-d4zxgcrictl logs 63acc9016d719touch: cannot touch &apos;/var/log/calico/cni/config&apos;: Read-only file system./run: line 5: /var/log/calico/cni/config: Read-only file system./run: line 6: /var/log/calico/cni/config: Read-only file systemsvlogd: warning: unable to lock directory: /var/log/calico/cni: read-only file systemsvlogd: fatal: no functional log directories.2022-09-21 03:12:49.496 [INFO][114] felix/watchercache.go 194: Failed to perform list of current data during resync ListRoot=&quot;/calico/resources/v3/projectcalico.org/kubernetesservice&quot; error=connection is unauthorized: Unauthorized2022-09-21 03:12:49.496 [INFO][114] felix/watchercache.go 194: Failed to perform list of current data during resync ListRoot=&quot;/calico/resources/v3/projectcalico.org/kubernetesendpointslices&quot; error=connection is unauthorized: Unauthorized2022-09-21 03:12:49.496 [INFO][114] felix/watchercache.go 194: Failed to perform list of current data during resync ListRoot=&quot;/calico/resources/v3/projectcalico.org/nodes&quot; error=connection is unauthorized: Unauthorized2022-09-21 03:12:49.496 [INFO][114] felix/watchercache.go 194: Failed to perform list of current data during resync ListRoot=&quot;/calico/resources/v3/projectcalico.org/profiles&quot; error=connection is unauthorized: Unauthorized2022-09-21 03:12:49.496 [INFO][114] felix/watchercache.go 194: Failed to perform list of current data during resync ListRoot=&quot;/calico/resources/v3/projectcalico.org/kubernetesnetworkpolicies&quot; error=connection is unauthorized: Unauthorized</code></pre><p>查看apiserver-audit日志<br><!--lang:bash--><br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”4998220b-d5f1-4b53-b01d-b8f4ee39ae09”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/bgpconfigurations?limit=500\u0026resourceVersion=8942985\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”bgpconfigurations”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.593700Z”,”stageTimestamp”:”2022-09-21T03:16:09.610291Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”e50fb629-cdd0-4b61-8ea9-3bf1b803a98c”,”stage”:”ResponseStarted”,”requestURI”:”/apis/networking.k8s.io/v1/networkpolicies?limit=500\u0026resourceVersion=9269250\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”networkpolicies”,”apiGroup”:”networking.k8s.io”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.636907Z”,”stageTimestamp”:”2022-09-21T03:16:09.653331Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”80248d89-941b-4648-956d-a023df326ba9”,”stage”:”ResponseStarted”,”requestURI”:”/apis/discovery.k8s.io/v1/endpointslices?limit=500\u0026resourceVersion=9069772\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”endpointslices”,”apiGroup”:”discovery.k8s.io”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.636880Z”,”stageTimestamp”:”2022-09-21T03:16:09.653339Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”deceeb71-87a4-46b9-ab7c-3d8ca81454c3”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/hostendpoints?limit=500\u0026resourceVersion=9269253\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”hostendpoints”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.644403Z”,”stageTimestamp”:”2022-09-21T03:16:09.660827Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”e52fd99b-689f-40d0-a030-4f5aacb16e04”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/bgpconfigurations?limit=500\u0026resourceVersion=8942985\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”bgpconfigurations”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.699502Z”,”stageTimestamp”:”2022-09-21T03:16:09.715845Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”4806e24f-7039-413c-9d1d-ac7513ae515f”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/felixconfigurations?limit=500\u0026resourceVersion=9269237\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”felixconfigurations”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.710565Z”,”stageTimestamp”:”2022-09-21T03:16:09.727257Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”d3d49793-ae7c-4b34-9b17-42fc5d1c6ce1”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/networkpolicies?limit=500\u0026resourceVersion=9269253\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”networkpolicies”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.722319Z”,”stageTimestamp”:”2022-09-21T03:16:09.738673Z”}<br>    {“kind”:”Event”,”apiVersion”:”audit.k8s.io/v1”,”level”:”Metadata”,”auditID”:”17f60f0f-16b3-491f-aede-6942139e5e3b”,”stage”:”ResponseStarted”,”requestURI”:”/apis/crd.projectcalico.org/v1/ipamblocks?limit=500\u0026resourceVersion=9066444\u0026resourceVersionMatch=NotOlderThan”,”verb”:”list”,”user”:{},”sourceIPs”:[“10.x.x.x”],”userAgent”:”Go-http-client/2.0”,”objectRef”:{“resource”:”ipamblocks”,”apiGroup”:”crd.projectcalico.org”,”apiVersion”:”v1”},”responseStatus”:{“metadata”:{},”status”:”Failure”,”reason”:”Unauthorized”,”code”:401},”requestReceivedTimestamp”:”2022-09-21T03:16:09.788846Z”,”stageTimestamp”:”2022-09-21T03:16:09.805174Z”}</p><p>修改前<br><!--lang:yaml--></p><pre><code>- name: cni-log-dir  mountPath: /var/log/calico/cni  readOnly: true</code></pre><p>修改后<br><!--lang:yaml--></p><pre><code>- name: cni-log-dir  mountPath: /var/log/calico/cni  readOnly: false</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;## &lt;/p&gt;
&lt;p&gt;查看calico node日志&lt;br&gt;&lt;!--lang:bash--&gt;&lt;br&gt;    crictl ps&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CONTAINER           IMAGE               CREATED           </summary>
      
    
    
    
    <category term="K8S" scheme="http://tech.mts.cab/categories/K8S/"/>
    
    
    <category term="K8S metrics server" scheme="http://tech.mts.cab/tags/K8S-metrics-server/"/>
    
  </entry>
  
  <entry>
    <title>K8S证书</title>
    <link href="http://tech.mts.cab/2015/12/13/k8s_certificate/"/>
    <id>http://tech.mts.cab/2015/12/13/k8s_certificate/</id>
    <published>2015-12-13T06:41:00.000Z</published>
    <updated>2022-11-17T03:49:21.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="x509证书信息说明"><a href="#x509证书信息说明" class="headerlink" title="x509证书信息说明"></a>x509证书信息说明</h3><p>以下是kube-apiserver的证书示例<br><!--lang:bash--></p><pre><code>Certificate:    Data:        Version: 3 (0x2)              # 版本号         Serial Number: 12 (0xc)       # 序列号 对于所有的版本，同一个CA颁发的证书序列号都必须是唯一的。        Signature Algorithm: sha256WithRSAEncryption           # ID签名算法        Issuer: C = BJ, O = Tech, OU = SRE, CN = www.ca.com    # 颁发者名称        Validity                                               # 有效期             Not Before: Aug 14 10:01:46 2022 GMT            Not After : Aug 11 10:01:46 2032 GMT        Subject: C = BJ, ST = BJ, L = BJ, O = Tech, OU = SRE, CN = system:api-server        Subject Public Key Info:                    # 主题公钥信息            Public Key Algorithm: rsaEncryption     # 公钥算法                RSA Public-Key: (2048 bit)          # 公钥                Modulus:            Exponent: 65537 (0x10001)        X509v3 extensions:            X509v3 Authority Key Identifier:                        DirName:/C=BJ/O=Tech/OU=SRE/CN=www.ca.com                serial:BB:A3:04:8F:CF:8C:F8:99            X509v3 Basic Constraints:      # 用于指示一份证书是不是CA证书。                CA:FALSE            X509v3 Key Usage:     # 指定了这份证书包含的公钥可以执行的密码操作                Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment            X509v3 Extended Key Usage:    # 典型用法是指定叶子证书中的公钥的使用目的。它包括一系列的OID，每一个都指定一种用途                TLS Web Server Authentication, TLS Web Client Authentication            X509v3 Subject Alternative Name:     # 描述可以使用的主机名，IP地址等                DNS:www.kubernetes.com, DNS:master01.kubernetes.com, DNS:master02.kubernetes.com, IP Address:172.20.0.1   # 除了apiserver向外部暴露的域名，apiserver在集群内部对应的service ip，与需要加到这里    Signature Algorithm: sha256WithRSAEncryption  # 证书签名算法</code></pre><h3 id="kube-apiserver-证书相关配置"><a href="#kube-apiserver-证书相关配置" class="headerlink" title="kube-apiserver 证书相关配置"></a>kube-apiserver 证书相关配置</h3><!--lang:bash--><pre><code>--etcd-certfile string                     SSL certification file used to secure etcd communication.--cert-dir string                        The directory where the TLS certs are located. If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored. (default &quot;/var/run/kubernetes&quot;)--tls-cert-file string                   File containing the default x509 Certificate for HTTPS. (CA cert, if any, concatenated after server cert). If HTTPS serving is enabled, and --tls-cert-file and --tls-private-key-file are not provided, a self-signed certificate and key are generated for the public address and saved to the directory specified by --cert-dir.--tls-private-key-file string            File containing the default x509 private key matching --tls-cert-file.--tls-sni-cert-key namedCertKey          A pair of x509 certificate and private key file paths, optionally suffixed with a list of domain patterns which are fully qualified domain names, possibly with prefixed wildcard segments. The domain patterns also allow IP addresses, but IPs should only be used if the apiserver has visibility to the IP address requested by a client. If no domain patterns are provided, the names of the certificate are extracted. Non-wildcard matches trump over wildcard matches, explicit domain patterns trump over extracted names. For multiple key/certificate pairs, use the --tls-sni-cert-key multiple times. Examples: &quot;example.crt,example.key&quot; or &quot;foo.crt,foo.key:*.foo.com,foo.com&quot;. (default [])--client-ca-file string                             If set, any request presenting a client certificate signed by one of the authorities in the client-ca-file is authenticated with an identity corresponding to the CommonName of the client certificate.--oidc-ca-file string                               If set, the OpenID server&apos;s certificate will be verified by one of the authorities in the oidc-ca-file, otherwise the host&apos;s root CA set will be used.--requestheader-allowed-names strings               List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.--requestheader-client-ca-file string               Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers. WARNING: generally do not depend on authorization being already done for incoming requests.--kubelet-certificate-authority string        Path to a cert file for the certificate authority.--kubelet-client-certificate string           Path to a client cert file for TLS.--proxy-client-cert-file string               Client certificate used to prove the identity of the aggregator or kube-apiserver when it must call out during a request. This includes proxying requests to a user api-server and calling out to webhook admission plugins. It is expected that this cert includes a signature from the CA in the --requestheader-client-ca-file flag. That CA is published in the &apos;extension-apiserver-authentication&apos; configmap in the kube-system namespace. Components receiving calls from kube-aggregator should use that CA to perform their half of the mutual TLS verification.--proxy-client-key-file string                Private key for the client certificate used to prove the identity of the aggregator or kube-apiserver when it must call out during a request. This includes proxying requests to a user api-server and calling out to webhook admission plugins.</code></pre><p>对应以下几种需要证书通信的配置</p><ul><li>client(kubectl，restapi等)：普通用户作为client与apiserver之间的通信，对各类资源进行操作<ul><li>apiserver本身是一个http服务器，需要tls证书，对应以下两个配置<ul><li>–tls-cert-file</li><li>–tls-private-key-file</li></ul></li><li>apiserver也需要对client进行验证，但是client过多，因此需要统一的ca签发client证书<ul><li>–client-ca-file</li><li>除此以外，apiserver需要通过证书确认client的身份，通过CN和O来识别用户，开启RBAC的用户要配置CN和O做一些授权<ul><li>CN：Common Name，kube-apiserver 从证书中提取作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li><li>O：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)</li></ul></li></ul></li></ul></li><li>kubelet，kubeproxy：master与node之间的通信，存在两种模式，1是kubelet，kubeproxy作为client，去访问apiserver，2是apiserver作为client，去访问1是kubelet<ul><li>kubelet，kubeproxy作为client，去访问apiserver(与上述client 访问模式类似)</li><li>apiserver作为client，去访问kubelet的相关配置<ul><li>–kubelet-client-certificate  apiserver 作为client的证书</li><li>–kubelet-client-key apiserver 作为client的证书密钥</li><li>–kubelet-preferred-address-types  </li><li>–kubelet-certificate-authority  kubelet server证书的ca</li></ul></li><li>kubelet 作为server的证书配置(以下3个命令行配置在后续版本会挪到–config指定的配置文件中)，<ul><li>–tls-cert-file  kubelet 作为server的证书(在实际的部署过程中，该证书不建议手动生成，由集群统一签发，签发到–cert-dir= 参数指定的路径)</li><li>–tls-private-key-file  kubelet 作为server的证书密钥</li><li>–client-ca-file</li></ul></li></ul></li><li>etcd：k8s的存储库,主要是apiserver作为client，去访问etcd server<ul><li>apiserver作为client的配置<ul><li>–etcd-cafile etcd server证书的ca</li><li>–etcd-certfile etcd server的证书</li><li>–etcd-keyfile  etcd server证书的密钥</li></ul></li><li>etcd 作为server的相关配置<ul><li>–cert-file etcd 作为server的证书</li><li>–key-file etcd 作为server的证书密钥</li></ul></li></ul></li><li>webhook：这里指apiserver提供的admission-webhook，在数据持久化前调用webhook</li><li><p>aggregation layer：扩展apiserver, 需要将自定义的api注册到k8s中，相比CRD性能更新</p><ul><li>aggregation 访问流程</li></ul></li><li><p>pod: 在pod中调用apiserver (在pod中通过serviceacount认证，pod需要认证apiserver的证书，其他几种需要client和server双向认证。)</p><ul><li>serviecaccount同样在apiserver有两个证书配置<ul><li>–service-account-key-file  (service account issue的公钥，用于验证service account)</li><li>–service-account-signing-key-file (service-account-key-file 对应的密钥)</li></ul></li><li>对应controller也有一个配置项<ul><li>–service-account-private-key-file  (service-account-key-file 对应的密钥，与apiserver –service-account-signing-key-file 配置相同的密钥文件，用来实际签署service account tokens)</li></ul></li></ul></li></ul><script>var graph = new Q.Graph(canvas);graph.moveToCenter(0);graph.zoomOut(0,0);graph.zoomOut(0,0);function createSubGroup(name,x, y,network, renderColor){    var group = createGroup();    group.name = name;    if(renderColor){        group.setStyle(Q.Styles.RENDER_COLOR, renderColor);    }    var a = createImageNode("Router", 49 + x, 100 + y,"router.png" , group);    var b = createImageNode("Switch", 191 + x, 100 + y,"exchange.png" , group);    var c = createImageNode( "PC", 313 + x, 100 + y,"pc.png", group);    createText(network, 191 + x, 160 + y, 14, Colors.dark, group);    createEdge("",a, b, "#45E");    createEdge("",c, b, "#45E");    return a;}var VPNFlexEdgeUI = function(edge, graph){Q.doSuperConstructor(this, VPNFlexEdgeUI, arguments);}VPNFlexEdgeUI.prototype = {drawEdge: function(path, fromUI, toUI, edgeType, fromBounds, toBounds){var from = fromBounds.center;path.curveTo(from.x, from.y, internet.x, internet.y);}}Q.extend(VPNFlexEdgeUI, Q.EdgeUI);var cloud_group = createGroup(100);graph.styles = {};graph.styles[Q.Styles.LABEL_FONT_SIZE] = 16;//var qunee = createCVMNode("Qunee", 100, 50);var ip1 = "Database \n WanIp:100.1.100.1 \n LanIP:10.1.10.1";var ip2 = "WebServer \n WanIp:100.1.100.2 \n LanIP:10.1.10.2";var ip3 = "GateWay \n WanIp:100.1.100.3 \n LanIP:10.1.10.3";var cloud_server1 = createServerNode(ip1,140,0,cloud_group);var cloud_server2 = createServerNode(ip2,340,0,cloud_group);var cloud_server3 = createServerNode(ip3,340,200,cloud_group);var cloud_switch = createSwitchNode("Switch",140,200,cloud_group);createText("Public Cloud", 250, -80, 24, Colors.dark, cloud_group);createEdge("",cloud_server1, cloud_switch, "#45E");createEdge("",cloud_server2, cloud_switch, "#45E");createEdge("",cloud_server3, cloud_switch, "#45E");var internet = createImageNode( "Internet", 600, 295,graphs.group_cloud);internet.setStyle(Q.Styles.LABEL_ANCHOR_POSITION, Q.Position.CENTER_MIDDLE);internet.setStyle(Q.Styles.LABEL_POSITION, Q.Position.CENTER_MIDDLE);internet.setStyle(Q.Styles.LABEL_FONT_SIZE, 24);internet.setStyle(Q.Styles.LABEL_FONT_STYLE, "bold");internet.size = {width: 200};remote = createTerminal("Remote Access",900,-50);createEdge("",cloud_group, internet, "#45E");sub1 = createSubGroup("Beijing",700,100,"192.168.2.0/24")sub2 = createSubGroup("Tianjin",700,300,"192.168.3.0/24")createEdge("",sub1, internet, "#45E");createEdge("",sub2, internet, "#45E");createEdge("",remote, internet, "#45E");createEdge("IPsec",sub1, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;createEdge("IPsec",sub2, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;createEdge("OPENVPN \n 172.16.1.0/24",remote, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;x509证书信息说明&quot;&gt;&lt;a href=&quot;#x509证书信息说明&quot; class=&quot;headerlink&quot; title=&quot;x509证书信息说明&quot;&gt;&lt;/a&gt;x509证书信息说明&lt;/h3&gt;&lt;p&gt;以下是kube-apiserver的证书示例&lt;br&gt;&lt;!--lang:bas</summary>
      
    
    
    
    <category term="K8S" scheme="http://tech.mts.cab/categories/K8S/"/>
    
    
    <category term="K8S 证书" scheme="http://tech.mts.cab/tags/K8S-%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>metric server部署问题排查</title>
    <link href="http://tech.mts.cab/2015/12/13/metric_server_troubleshooting/"/>
    <id>http://tech.mts.cab/2015/12/13/metric_server_troubleshooting/</id>
    <published>2015-12-13T06:41:00.000Z</published>
    <updated>2022-11-14T10:59:39.267Z</updated>
    
    <content type="html"><![CDATA[<p>## </p><p>开启调试模式<br><!--lang:bash--></p><pre><code>--v=0    Generally useful for this to ALWAYS be visible to an operator.--v=1    A reasonable default log level if you don’t want verbosity.--v=2    Useful steady state information about the service and important log messages that may correlate to significant changes in the system. This is the recommended default log level for most systems.--v=3    Extended information about changes.--v=4    Debug level verbosity.--v=6    Display requested resources.--v=7    Display HTTP request headers.--v=8    Display HTTP request contentsI0921 12:16:09.553440       1 request.go:1181] Response Body: &#123;&quot;kind&quot;:&quot;SubjectAccessReview&quot;,&quot;apiVersion&quot;:&quot;authorization.k8s.io/v1&quot;,&quot;metadata&quot;:&#123;&quot;creationTimestamp&quot;:null,&quot;managedFields&quot;:[&#123;&quot;manager&quot;:&quot;Go-http-client&quot;,&quot;operation&quot;:&quot;Update&quot;,&quot;apiVersion&quot;:&quot;authorization.k8s.io/v1&quot;,&quot;time&quot;:&quot;2022-09-21T04:16:09Z&quot;,&quot;fieldsType&quot;:&quot;FieldsV1&quot;,&quot;fieldsV1&quot;:&#123;&quot;f:spec&quot;:&#123;&quot;f:groups&quot;:&#123;&#125;,&quot;f:nonResourceAttributes&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:path&quot;:&#123;&#125;,&quot;f:verb&quot;:&#123;&#125;&#125;,&quot;f:user&quot;:&#123;&#125;&#125;&#125;&#125;]&#125;,&quot;spec&quot;:&#123;&quot;nonResourceAttributes&quot;:&#123;&quot;path&quot;:&quot;/apis/metrics.k8s.io/v1beta1&quot;,&quot;verb&quot;:&quot;get&quot;&#125;,&quot;user&quot;:&quot;system:anonymous&quot;,&quot;groups&quot;:[&quot;system:unauthenticated&quot;]&#125;,&quot;status&quot;:&#123;&quot;allowed&quot;:false&#125;&#125;E0921 15:10:14.898275       1 scraper.go:140] &quot;Failed to scrape node&quot; err=&quot;Get \&quot;https://10.131.66.67:10250/metrics/resource\&quot;: x509: cannot validate certificate for 10.131.66.67 because it doesn&apos;t contain any IP SANs&quot; node=&quot;sg5-shopee-toc-monitor-live-10-131-66-67&quot;</code></pre><p>kube-apiserver 中指定的<br>  –requestheader-client-ca-file= 对应metric-server中–client-ca-file<br>  –proxy-client-cert-file= 需要用–requestheader-client-ca-file= 指定的ca签名</p><p><a href="https://blog.csdn.net/u012986012/article/details/105746492">https://blog.csdn.net/u012986012/article/details/105746492</a></p><p>kubelet server证书问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;## &lt;/p&gt;
&lt;p&gt;开启调试模式&lt;br&gt;&lt;!--lang:bash--&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--v=0    Generally useful for this to ALWAYS be visible to an operator.
--v=1    A r</summary>
      
    
    
    
    <category term="K8S" scheme="http://tech.mts.cab/categories/K8S/"/>
    
    
    <category term="K8S metrics server" scheme="http://tech.mts.cab/tags/K8S-metrics-server/"/>
    
  </entry>
  
  <entry>
    <title>基于公有云建设私有网络（二）</title>
    <link href="http://tech.mts.cab/2015/11/26/CentOS_IPsec/"/>
    <id>http://tech.mts.cab/2015/11/26/CentOS_IPsec/</id>
    <published>2015-11-26T07:41:00.000Z</published>
    <updated>2022-09-20T10:23:00.859Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客中，介绍了下网络拓扑的规划和设计，现在，着重介绍下CentOS与H3C路由器的ipsecVPN的配置，CentOS使用的软件包是openswan，由于办公网络使用的是民用网，出口IP不固定，因此采用ike野蛮模式进行协商</p><h2 id="IPsec介绍"><a href="#IPsec介绍" class="headerlink" title="IPsec介绍"></a>IPsec介绍</h2><p>IPsec 协议工作在OSI 模型的第三层，使其在单独使用时适于保护基于TCP或UDP的协议（如 安全套接子层（SSL）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。它有两种安全协议，分别是AH和ESP，AH主要提供身份验证和数据完整性验证，ESP则提供身份验证，数据完整性验证以及加密功能（我们选用ESP）。封装模式有传输模式和隧道模式（我们选择隧道模式）。密钥管理采用ISAKMP。详细内容可以到H3C的<br><a href="http://www.h3c.com.cn/Service/Channel_Service/Operational_Service/ICG_Technology/201005/675214_30005_0.htm">IPsec原理</a>介绍帖子中查看，讲的挺详细的。</p><h2 id="CentOS配置"><a href="#CentOS配置" class="headerlink" title="CentOS配置"></a>CentOS配置</h2><p>CentOS中可以通过yum安装对应的包</p><!--lang:bash--><pre><code>yum install epel-releaseyum install openswan</code></pre><p>修改/添加 /etc/sysctl.conf</p><!--lang:bash--><pre><code>net.ipv4.ip_forward = 1net.ipv4.conf.default.accept_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.eth0.rp_filter = 0net.ipv4.conf.default.rp_filter = 0</code></pre><p>然后将上述配置生效</p><!--lang:bash--><pre><code>sysctl -p</code></pre><p>修改/添加ipsec配置文件/etc/ipsec.conf</p><!--lang:bash--><pre><code>config setup    protostack=netkey    listen=100.1.100.3    plutodebug=none    plutostderrlog=/data/ipsec/log/pluto.log    dumpdir=/data/ipsec/pluto/    nat_traversal=yes    virtual_private=%v4:10.0.0.0/8,%v4:192.168.0.0/16,%v4:172.16.0.0/12    include /etc/ipsec.d/*.conf</code></pre><ol start="5"><li>添加各分部配置文件（在/etc/ipsec.d/下）<br>公有云到北京分部cloud_to_bj.conf</li></ol><!--lang:bash--><pre><code>conn    cloud_to_bj_net    connaddrfamily=ipv4    aggrmode=yes    authby=secret    auto=start    ike=aes128-sha1;modp1024    ## phase 1 ##    keyexchange=ike    ## phase 2 ##    phase2=esp    phase2alg=aes128-sha1;modp1024    compress=no    pfs=yes    type=tunnel    left=100.1.100.3    leftsubnet=172.16.0.0/16    leftid=@cloud.cloud.com    right=%any    rightsubnet=192.168.2.0/24    rightid=@bj.bj.com</code></pre><p>公有云到天津分部cloud_to_tj.conf</p><!--lang:bash--><pre><code>conn    cloud_to_bj_net    connaddrfamily=ipv4    aggrmode=yes    authby=secret    auto=start    ike=aes128-sha1;modp1024    ## phase 1 ##    keyexchange=ike    ## phase 2 ##    phase2=esp    phase2alg=aes128-sha1;modp1024    compress=no    pfs=yes    type=tunnel    left=100.1.100.3    leftsubnet=172.16.0.0/16    leftid=@cloud2.cloud.com    right=%any    rightsubnet=192.168.3.0/24    rightid=@tj.tj.com</code></pre><p>北京分部到天津分部bj_to_tj.conf<br><!--lang:bash--></p><pre><code>conn   bj_to_tj_net    connaddrfamily=ipv4    aggrmode=yes    authby=secret    auto=start    ike=aes128-sha1;modp1024    ## phase 1 ##    keyexchange=ike    ## phase 2 ##    phase2=esp    phase2alg=aes128-sha1;modp1024    compress=no    pfs=yes    type=tunnel    left=100.1.100.3    leftsubnet=192.168.2.0/24    leftid=@cloud1.cloud.com    right=%any    rightsubnet=192.168.3.0/24    rightid=@tj1.tj.com</code></pre><p>天津分部到北京分部tj_to_bj.conf</p><!--lang:bash--><pre><code>conn   tj_to_bj_netconnaddrfamily=ipv4aggrmode=yesauthby=secretauto=startike=aes128-sha1;modp1024## phase 1 ##keyexchange=ike## phase 2 ##phase2=espphase2alg=aes128-sha1;modp1024compress=nopfs=yestype=tunnelleft=100.1.100.3leftsubnet=192.168.3.0/24leftid=@cloud3.cloud.comright=%anyrightsubnet=192.168.2.0/24rightid=@bj1.bj.com</code></pre><p>设置预共享密钥，在/etc/ipsec.d/下创建cloud.secrets,添加如下内容</p><!--lang:bash--><pre><code>100.1.100.3   %any:   PSK &quot;123456&quot; </code></pre><p><font color=red>注：123456为预共享密钥，正式设置时一定要修改成一个安全的值</font><br>启动以及验证ipsec服务</p><!--lang:bash--><pre><code>service ipsec startchkconfig ipsec onipsec verify</code></pre><p>结果如下即可</p><!--lang:bash--><pre><code>erifying installed system and configuration filesVersion check and ipsec on-path                       [OK]Libreswan 3.8 (netkey) on 3.10.0-123.9.3.el7.x86_64Checking for IPsec support in kernel                  [OK]NETKEY: Testing XFRM related proc values     ICMP default/send_redirects                  [OK]     ICMP default/accept_redirects                [OK]     XFRM larval drop                             [OK]Pluto ipsec.conf syntax                               [OK]Hardware random device                                [N/A]Checking rp_filter                                    [OK]Checking that pluto is running                        [OK]Pluto listening for IKE on udp 500                   [OK]Pluto listening for IKE/NAT-T on udp 4500            [OK]Pluto ipsec.secret syntax                            [OK]Checking NAT and MASQUERADEing                        [TEST INCOMPLETE]Checking &apos;ip&apos; command                                 [OK]  Checking &apos;iptables&apos; command                           [OK]Checking &apos;prelink&apos; command does not interfere with FIPSChecking for obsolete ipsec.conf options              [OK]Opportunistic Encryption                              [DISABLED]</code></pre><h2 id="H3C路由器配置"><a href="#H3C路由器配置" class="headerlink" title="H3C路由器配置"></a>H3C路由器配置</h2><p>北京分部路由器<br>配置ike proposal</p><!--lang:bash--><pre><code>ike proposal 1encryption-algorithm aes-cbc 128dh group2</code></pre><p>配置ikepeer</p><!--lang:bash--><pre><code>ike peer bj_cloudexchange-mode aggressiveproposal 1pre-shared-key simple 123456id-type nameremote-name cloud.cloud.comremote-address 100.1.100.3local-name bj.bj.comnat traversalike peer bj_tjexchange-mode aggressiveproposal 1pre-shared-key simple 123456id-type nameremote-name cloud3.cloud.comremote-address 100.1.100.3local-name bj1.bj.comnat traversal</code></pre><p>配置ipsec transform-set</p><!--lang:bash--><pre><code>ipsec transform-set bjencapsulation-mode tunneltransform espesp authentication-algorithm sha1esp encryption-algorithm aes-cbc-128</code></pre><p>配置ipsec policy</p><!--lang:bash--><pre><code>ipsec policy bj 1 isakmpsecurity acl 3000pfs dh-group2ike-peer bj_cloudtransform-set bj ipsec policy bj 2 isakmpsecurity acl 3001pfs dh-group2ike-peer bj_cloudtransform-set bj</code></pre><p>配置感兴趣流</p><!--lang:bash--><pre><code>acl number 3000rule 0 permit ip source 192.168.2.0 0.0.0.255 destination 172.16.0.0 0.0.255.255rule 20 deny ipacl number 3001rule 0 permit ip source 192.168.2.0 0.0.0.255 destination 192.168.3.0 0.0.0.255rule 20 deny ip</code></pre><p>在接口上启用ipsec</p><!--lang:bash--><pre><code>interface Dialup 1ipsec policy bj</code></pre><p>天津出口路由器跟北京路由器的配置类似</p><h2 id="iptables虚拟公有云172-16-2-0-24虚拟网段"><a href="#iptables虚拟公有云172-16-2-0-24虚拟网段" class="headerlink" title="iptables虚拟公有云172.16.2.0/24虚拟网段"></a>iptables虚拟公有云172.16.2.0/24虚拟网段</h2><p>在办公网络通过172.16.2.1:3306访问在Database上监听10.1.10.1:3306的数据库，为10.1.10.3授权一个只读账号<br>通过snat+dnat实现，在iptables nat表中添加如下内容</p><!--lang:bash--><pre><code>-A PREROUTING -d 172.16.2.1/32 -p tcp -m tcp --dport 3306 -j DNAT --to-destination 10.1.10.1-A POSTROUTING -s 192.168.2.0/24 -o eth0 -p tcp -j MASQUERADE-A POSTROUTING -s 172.16.1.0/24 -o eth0 -p tcp -j MASQUERADE-A POSTROUTING -s  192.168.3.0/24 -o eth0 -p tcp -j MASQUERADE</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇博客中，介绍了下网络拓扑的规划和设计，现在，着重介绍下CentOS与H3C路由器的ipsecVPN的配置，CentOS使用的软件包是openswan，由于办公网络使用的是民用网，出口IP不固定，因此采用ike野蛮模式进行协商&lt;/p&gt;
&lt;h2 id=&quot;IPsec介绍&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="网络技术" scheme="http://tech.mts.cab/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VPN IPsec 网络 GRE" scheme="http://tech.mts.cab/tags/VPN-IPsec-%E7%BD%91%E7%BB%9C-GRE/"/>
    
  </entry>
  
  <entry>
    <title>基于公有云建设私有网络（一）</title>
    <link href="http://tech.mts.cab/2015/11/26/Centos_ipsec_VPN/"/>
    <id>http://tech.mts.cab/2015/11/26/Centos_ipsec_VPN/</id>
    <published>2015-11-26T07:41:00.000Z</published>
    <updated>2022-09-20T10:23:00.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>在现今多种多样的需求以及复杂的网络环境下，VPN的使用场景越来越多，不同类型的vpn用于不同的场景，例如，ssl，l2tp,pptp，openvpn这种vpn主要用于翻墙，企业远程办公等场景；ipsec vpn或者gre over ipsec vpn被用于企业多办公地点的内网打通；<br>在云计算火热的今天，vpn的隧道技术亦被应用于云计算基础网络架构之中，公有云的浮动IP，VPC SDN网络的建设，无不是利用vpn隧道来屏蔽底层交换机，机架的物理位置带来的限制。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在创业或者小型企业的发展过程中，应用比较多的应该是ipsec或者gre over ipsec vpn，创业型的企业，发展初期很难有有自己的机房，内部的系统基本都会在公有云上建设，但是有一些内部系统又不希望通过公网直接访问，甚至到一定阶段会多个办公地点以及有部分员工远程办公的需求，这就需要用到vpn来解决这些问题。</p><p>创业企业由于资金问题，在创业初期办公环境不会使用商用网络，而是使用相对便宜的民用网络,所以一旦出现多个办公地点，没有办法直接建立vpn，需要通过公有云服务器打通多个办公地点的内网，同时通过公有云服务器，为远程办公的人员提供接入点</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>言归正传，先上图<br>简易拓扑图如下</p><p><div style="height: 500px;" id="canvas"/></p><script>var graph = new Q.Graph(canvas);graph.moveToCenter(0);graph.zoomOut(0,0);graph.zoomOut(0,0);function createSubGroup(name,x, y,network, renderColor){    var group = createGroup();    group.name = name;    if(renderColor){        group.setStyle(Q.Styles.RENDER_COLOR, renderColor);    }    var a = createImageNode("Router", 49 + x, 100 + y,"router.png" , group);    var b = createImageNode("Switch", 191 + x, 100 + y,"exchange.png" , group);    var c = createImageNode( "PC", 313 + x, 100 + y,"pc.png", group);    createText(network, 191 + x, 160 + y, 14, Colors.dark, group);    createEdge("",a, b, "#45E");    createEdge("",c, b, "#45E");    return a;}var VPNFlexEdgeUI = function(edge, graph){    Q.doSuperConstructor(this, VPNFlexEdgeUI, arguments);}VPNFlexEdgeUI.prototype = {    drawEdge: function(path, fromUI, toUI, edgeType, fromBounds, toBounds){        var from = fromBounds.center;        path.curveTo(from.x, from.y, internet.x, internet.y);    }}Q.extend(VPNFlexEdgeUI, Q.EdgeUI);var cloud_group = createGroup(100);graph.styles = {};graph.styles[Q.Styles.LABEL_FONT_SIZE] = 16;//var qunee = createCVMNode("Qunee", 100, 50);var ip1 = "Database \n WanIp:100.1.100.1 \n LanIP:10.1.10.1";var ip2 = "WebServer \n WanIp:100.1.100.2 \n LanIP:10.1.10.2";var ip3 = "GateWay \n WanIp:100.1.100.3 \n LanIP:10.1.10.3";var cloud_server1 = createServerNode(ip1,140,0,cloud_group);var cloud_server2 = createServerNode(ip2,340,0,cloud_group);var cloud_server3 = createServerNode(ip3,340,200,cloud_group);var cloud_switch = createSwitchNode("Switch",140,200,cloud_group);createText("Public Cloud", 250, -80, 24, Colors.dark, cloud_group);createEdge("",cloud_server1, cloud_switch, "#45E");createEdge("",cloud_server2, cloud_switch, "#45E");createEdge("",cloud_server3, cloud_switch, "#45E");var internet = createImageNode( "Internet", 600, 295,graphs.group_cloud);internet.setStyle(Q.Styles.LABEL_ANCHOR_POSITION, Q.Position.CENTER_MIDDLE);internet.setStyle(Q.Styles.LABEL_POSITION, Q.Position.CENTER_MIDDLE);internet.setStyle(Q.Styles.LABEL_FONT_SIZE, 24);internet.setStyle(Q.Styles.LABEL_FONT_STYLE, "bold");internet.size = {width: 200};remote = createTerminal("Remote Access",900,-50);createEdge("",cloud_group, internet, "#45E");sub1 = createSubGroup("Beijing",700,100,"192.168.2.0/24")sub2 = createSubGroup("Tianjin",700,300,"192.168.3.0/24")createEdge("",sub1, internet, "#45E");createEdge("",sub2, internet, "#45E");createEdge("",remote, internet, "#45E");createEdge("IPsec",sub1, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;createEdge("IPsec",sub2, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;createEdge("OPENVPN \n 172.16.1.0/24",remote, cloud_server3, "#F80", true).uiClass = VPNFlexEdgeUI;</script><table><thead><tr><th style="text-align:center">位置</th><th style="text-align:center">设备</th><th style="text-align:center">公网IP</th><th style="text-align:center">内网IP/网段</th><th style="text-align:center">VIP/网段</th></tr></thead><tbody><tr><td style="text-align:center">公有云</td><td style="text-align:center">GateWay</td><td style="text-align:center">100.1.100.3</td><td style="text-align:center">10.1.10.3</td><td style="text-align:center">172.16.1.1</td></tr><tr><td style="text-align:center">公有云</td><td style="text-align:center">WebServer</td><td style="text-align:center">100.1.100.2</td><td style="text-align:center">10.1.10.2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">公有云</td><td style="text-align:center">Database</td><td style="text-align:center">100.1.100.1</td><td style="text-align:center">10.1.10.1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">北京办公区</td><td style="text-align:center">Router</td><td style="text-align:center">随机</td><td style="text-align:center">192.168.2.0/24</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">天津办公区</td><td style="text-align:center">Router</td><td style="text-align:center">随机</td><td style="text-align:center">192.168.3.0/24</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">远程办公</td><td style="text-align:center">PC</td><td style="text-align:center">随机</td><td style="text-align:center">随机</td><td style="text-align:center">172.16.0.1/24</td></tr></tbody></table><p>如上图以及表格所示：<br>1、北京办公区和天津办公区域与公有云GateWay服务器建立ipsec VPN ，感兴趣流设置为<font color=red>192.168.2.0/24，192.168.3.0/24，172.16.0.1/24</font>（为了与远程办公实现内网通信）<br>2、远程办公与 GateWay建立openvpn隧道，服务器给客户端推送路由<font color=red>192.168.2.0/24，192.168.3.0/24</font><br>3、在日常开发的过程中，会涉及到线上数据库的只读访问，如果直接开放数据库的公网访问权限，会很不安全，此时可以在GateWay服务器上通过DNAT+SNAT的方法，给办公网的用户以及远程办公的用户虚拟一个172.16.2.0/24的网段用以以内网的形式访问公有云中除GateWay其他的云计算的资源</p><font color=red><br>注：<br>1、远程办公选用openvpn，一是因为openvpn是加密的vpn，更重要的是openvpn可以由服务端给客户端推送路由；<br>2、以上第三点只用作日常开发使用，不可用于业务<br></font><p>通过此方案，即可在一个小的创业公司建立起公司的内网办公体系，当然，如果使用了公有云的私有网络功能，则不需要这么麻烦，可以有更优雅的解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h2&gt;&lt;p&gt;在现今多种多样的需求以及复杂的网络环境下，VPN的使用场景越来越多，不同类型的vpn用于不同的场景，例如，s</summary>
      
    
    
    
    <category term="网络技术" scheme="http://tech.mts.cab/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VPN IPsec 网络 GRE" scheme="http://tech.mts.cab/tags/VPN-IPsec-%E7%BD%91%E7%BB%9C-GRE/"/>
    
  </entry>
  
  <entry>
    <title>关于博客</title>
    <link href="http://tech.mts.cab/2015/11/21/about_blog/"/>
    <id>http://tech.mts.cab/2015/11/21/about_blog/</id>
    <published>2015-11-21T13:33:00.000Z</published>
    <updated>2022-09-20T10:23:00.860Z</updated>
    
    <content type="html"><![CDATA[<p>不困于过去，不安于现在，不畏于将来</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>14年9月的时候，开始在github上折腾博客，心想着要坚持记录自己成长的点点滴滴，然而坚持到了12月份，却慢慢的由于各方面的原因（加班，夜班，社交活动，编写博客的笔记本环境系统重装），把总结自己的时间一点一点挤没了，对于新的东西，总是有很大的激情去体验，去尝试，但是由于各方面的因素，遇到的各种困难而慢慢的难以坚持下去，现在的我，已经毕业两年了，两年里基本是被工作压迫着成长，不断的接触着新的东西，鲜有思考和沉淀的时间。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>写博客，是需要静心总结和思考的，维护一个博客，其实就是运营一个网站。工作以后，发现时间，环境已然不是那么规律，可以预见。每月，每周，每天都会有预想不到的变化，计划永远赶不上变化，加班，岗位调用，工作变迁，以及相应的带来生活上的变化，想要每天，每周或者每月挤出自己的时间来并不容易。学会记录，学会总结，学会持久的去坚持做好一件事情，是我现在需要锻炼的一项能力，或者说，把写博客变成一种习惯。</p><h2 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h2><p>以后有什么变化，无法预知，但学习和成长是个不变的话题，如果我能看的更远一些 那是因为我站在巨人的肩膀上，巨人是靠历史的积累，拥有过去，才能走的更远</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不困于过去，不安于现在，不畏于将来&lt;/p&gt;
&lt;h2 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h2&gt;&lt;p&gt;14年9月的时候，开始在github上折腾博客，心想着要坚持记录自己成长的点点滴滴，然而坚</summary>
      
    
    
    
    
  </entry>
  
</feed>
